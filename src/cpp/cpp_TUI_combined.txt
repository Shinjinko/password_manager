#include "../h/crypto.h"
#include <fstream>
#include <stdexcept>
#include <openssl/sha.h>
#include <openssl/err.h>
#include "../h/mmap_utils.h"

// Constructor: initialize Crypto object with password and key file
Crypto::Crypto(const std::string& password, const std::string& key_file) : key_file(key_file), ctx(nullptr) {
    initializeContext();
    loadOrGenerateMasterKey(password);
}

// Destructor: clean up OpenSSL context
Crypto::~Crypto() {
    if (ctx) {
        EVP_CIPHER_CTX_free(ctx);
        ctx = nullptr;
    }
}

// Initialize OpenSSL cipher context
void Crypto::initializeContext() {
    ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        throw std::runtime_error("Failed to create EVP context");
    }
}

// Load master key from file or generate a new one
void Crypto::loadOrGenerateMasterKey(const std::string& password) {
    // Check if key file exists
    if (std::ifstream(key_file)) {
        // Load and decrypt master key
        master_key = MMAPUtils::loadMasterKey(key_file, password);
    } else {
        // Generate new master key (32 bytes for AES-256)
        master_key.resize(32);
        if (RAND_bytes(reinterpret_cast<unsigned char*>(&master_key[0]), 32) != 1) {
            throw std::runtime_error("Failed to generate master key");
        }
        // Store master key in file
        MMAPUtils::storeMasterKey(key_file, master_key, password);
    }
}

// Static method to hash password using SHA-256
std::string Crypto::hashPassword(const std::string& password) {
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256_CTX sha256;
    SHA256_Init(&sha256);
    SHA256_Update(&sha256, password.c_str(), password.size());
    SHA256_Final(hash, &sha256);

    // Convert hash to hexadecimal string
    char hex[2 * SHA256_DIGEST_LENGTH + 1];
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        sprintf(hex + 2 * i, "%02x", hash[i]);
    }
    hex[2 * SHA256_DIGEST_LENGTH] = '\0';
    return std::string(hex);
}

// Encrypt plaintext using AES-256-GCM
std::string Crypto::encrypt(const std::string& plaintext) {
    if (plaintext.empty()) return "";

    unsigned char iv[12];
    if (RAND_bytes(iv, 12) != 1) {
        throw std::runtime_error("Failed to generate IV");
    }

    if (EVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, NULL) != 1 ||
        EVP_EncryptInit_ex(ctx, NULL, NULL, reinterpret_cast<const unsigned char*>(master_key.c_str()), iv) != 1) {
        throw std::runtime_error("Failed to initialize encryption");
    }

    std::string ciphertext;
    ciphertext.resize(plaintext.size() + EVP_MAX_BLOCK_LENGTH);
    int len, ciphertext_len = 0;

    if (EVP_EncryptUpdate(ctx, reinterpret_cast<unsigned char*>(&ciphertext[0]), &len,
                          reinterpret_cast<const unsigned char*>(plaintext.c_str()), plaintext.size()) != 1) {
        throw std::runtime_error("Failed to encrypt data");
    }
    ciphertext_len += len;

    if (EVP_EncryptFinal_ex(ctx, reinterpret_cast<unsigned char*>(&ciphertext[ciphertext_len]), &len) != 1) {
        throw std::runtime_error("Failed to finalize encryption");
    }
    ciphertext_len += len;

    unsigned char tag[16];
    if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_GET_TAG, 16, tag) != 1) {
        throw std::runtime_error("Failed to get GCM tag");
    }

    // Append IV and tag to ciphertext
    std::string result = std::string(reinterpret_cast<char*>(iv), 12) + ciphertext.substr(0, ciphertext_len) + std::string(reinterpret_cast<char*>(tag), 16);
    return result;
}

// Decrypt ciphertext using AES-256-GCM
std::string Crypto::decrypt(const std::string& ciphertext) {
    if (ciphertext.size() < 28) return ""; // Minimum size: 12 (IV) + 16 (tag)

    // Extract IV, ciphertext, and tag
    std::string iv = ciphertext.substr(0, 12);
    std::string tag = ciphertext.substr(ciphertext.size() - 16);
    std::string data = ciphertext.substr(12, ciphertext.size() - 28);

    if (EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, NULL) != 1 ||
        EVP_DecryptInit_ex(ctx, NULL, NULL, reinterpret_cast<const unsigned char*>(master_key.c_str()),
                           reinterpret_cast<const unsigned char*>(iv.c_str())) != 1) {
        throw std::runtime_error("Failed to initialize decryption");
    }

    std::string plaintext;
    plaintext.resize(data.size() + EVP_MAX_BLOCK_LENGTH);
    int len, plaintext_len = 0;

    if (EVP_DecryptUpdate(ctx, reinterpret_cast<unsigned char*>(&plaintext[0]), &len,
                          reinterpret_cast<const unsigned char*>(data.c_str()), data.size()) != 1) {
        throw std::runtime_error("Failed to decrypt data");
    }
    plaintext_len += len;

    if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, 16, const_cast<char*>(tag.c_str())) != 1) {
        throw std::runtime_error("Failed to set GCM tag");
    }

    if (EVP_DecryptFinal_ex(ctx, reinterpret_cast<unsigned char*>(&plaintext[plaintext_len]), &len) != 1) {
        throw std::runtime_error("Failed to finalize decryption");
    }
    plaintext_len += len;

    return plaintext.substr(0, plaintext_len);
}#include "../h/database.h"
#include <iostream>

Database::Database(const std::string& path) : db_path(path), db(nullptr) {
    int rc = sqlite3_open(db_path.c_str(), &db);
    if (rc != SQLITE_OK) {
        std::cerr << "Ошибка открытия базы данных: " << sqlite3_errmsg(db) << std::endl;
        sqlite3_close(db);
        db = nullptr;
    }
}

Database::~Database() {
    if (db) {
        sqlite3_close(db);
    }
}

bool Database::initialize() {
    if (!db) return false;

    const char* create_users_sql = 
        "CREATE TABLE IF NOT EXISTS users ("
        "id INTEGER PRIMARY KEY AUTOINCREMENT,"
        "username TEXT NOT NULL UNIQUE,"
        "password_hash TEXT NOT NULL,"
        "totp_secret TEXT NOT NULL);";

    const char* create_passwords_sql = 
        "CREATE TABLE IF NOT EXISTS passwords ("
        "id INTEGER PRIMARY KEY AUTOINCREMENT,"
        "user_id INTEGER NOT NULL,"
        "description TEXT NOT NULL,"
        "login TEXT NOT NULL,"
        "password BLOB NOT NULL,"
        "FOREIGN KEY (user_id) REFERENCES users (id));";

    char* err_msg = nullptr;
    int rc = sqlite3_exec(db, create_users_sql, nullptr, nullptr, &err_msg);
    if (rc != SQLITE_OK) {
        std::cerr << "Ошибка создания таблицы users: " << err_msg << std::endl;
        sqlite3_free(err_msg);
        return false;
    }

    rc = sqlite3_exec(db, create_passwords_sql, nullptr, nullptr, &err_msg);
    if (rc != SQLITE_OK) {
        std::cerr << "Ошибка создания таблицы passwords: " << err_msg << std::endl;
        sqlite3_free(err_msg);
        return false;
    }

    return true;
}

bool Database::registerUser(const std::string& username, const std::string& password_hash, const std::string& totp_secret) {
    if (!db) return false;

    const char* sql = "INSERT INTO users (username, password_hash, totp_secret) VALUES (?, ?, ?);";
    sqlite3_stmt* stmt;
    int rc = sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);
    if (rc != SQLITE_OK) {
        std::cerr << "Ошибка подготовки запроса: " << sqlite3_errmsg(db) << std::endl;
        return false;
    }

    sqlite3_bind_text(stmt, 1, username.c_str(), -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, password_hash.c_str(), -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, totp_secret.c_str(), -1, SQLITE_STATIC);

    rc = sqlite3_step(stmt);
    bool success = (rc == SQLITE_DONE);
    if (!success) {
        std::cerr << "Ошибка регистрации: " << sqlite3_errmsg(db) << std::endl;
    }

    sqlite3_finalize(stmt);
    return success;
}

bool Database::authenticateUser(const std::string& username, const std::string& password_hash, int& user_id, std::string& totp_secret) {
    if (!db) return false;

    const char* sql = "SELECT id, totp_secret FROM users WHERE username = ? AND password_hash = ?;";
    sqlite3_stmt* stmt;
    int rc = sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);
    if (rc != SQLITE_OK) {
        std::cerr << "Ошибка подготовки запроса: " << sqlite3_errmsg(db) << std::endl;
        return false;
    }

    sqlite3_bind_text(stmt, 1, username.c_str(), -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, password_hash.c_str(), -1, SQLITE_STATIC);

    rc = sqlite3_step(stmt);
    if (rc == SQLITE_ROW) {
        user_id = sqlite3_column_int(stmt, 0);
        totp_secret = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1));
        sqlite3_finalize(stmt);
        return true;
    }

    sqlite3_finalize(stmt);
    return false;
}

bool Database::addPassword(int user_id, const PasswordEntry& entry) {
    if (!db) return false;

    const char* sql = "INSERT INTO passwords (user_id, description, login, password) VALUES (?, ?, ?, ?);";
    sqlite3_stmt* stmt;
    int rc = sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);
    if (rc != SQLITE_OK) {
        std::cerr << "Ошибка подготовки запроса: " << sqlite3_errmsg(db) << std::endl;
        return false;
    }

    sqlite3_bind_int(stmt, 1, user_id);
    sqlite3_bind_text(stmt, 2, entry.description.c_str(), -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, entry.login.c_str(), -1, SQLITE_STATIC);
    sqlite3_bind_blob(stmt, 4, entry.password.data(), entry.password.size(), SQLITE_STATIC);

    rc = sqlite3_step(stmt);
    bool success = (rc == SQLITE_DONE);
    if (!success) {
        std::cerr << "Ошибка добавления записи: " << sqlite3_errmsg(db) << std::endl;
    }

    sqlite3_finalize(stmt);
    return success;
}

bool Database::removePassword(int user_id, const std::string& description) {
    if (!db) return false;

    const char* sql = "DELETE FROM passwords WHERE user_id = ? AND description = ?;";
    sqlite3_stmt* stmt;
    int rc = sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);
    if (rc != SQLITE_OK) {
        std::cerr << "Ошибка подготовки запроса: " << sqlite3_errmsg(db) << std::endl;
        return false;
    }

    sqlite3_bind_int(stmt, 1, user_id);
    sqlite3_bind_text(stmt, 2, description.c_str(), -1, SQLITE_STATIC);

    rc = sqlite3_step(stmt);
    bool success = (rc == SQLITE_DONE && sqlite3_changes(db) > 0);
    if (!success && sqlite3_changes(db) == 0) {
        std::cerr << "Запись не найдена!" << std::endl;
    }

    sqlite3_finalize(stmt);
    return success;
}

bool Database::getPasswords(int user_id, std::vector<PasswordEntry>& entries) {
    if (!db) return false;

    entries.clear();
    const char* sql = "SELECT description, login, password FROM passwords WHERE user_id = ?;";
    sqlite3_stmt* stmt;
    int rc = sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);
    if (rc != SQLITE_OK) {
        std::cerr << "Ошибка подготовки запроса: " << sqlite3_errmsg(db) << std::endl;
        return false;
    }

    sqlite3_bind_int(stmt, 1, user_id);

    while ((rc = sqlite3_step(stmt)) == SQLITE_ROW) {
        PasswordEntry entry;
        entry.description = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0));
        entry.login = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1));
        const void* blob = sqlite3_column_blob(stmt, 2);
        int blob_size = sqlite3_column_bytes(stmt, 2);
        entry.password = std::string(static_cast<const char*>(blob), blob_size);
        entries.push_back(entry);
    }

    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE || !entries.empty();
}#include "../h/exceptions.h"
#include <iostream>
#include <limits>

namespace Exceptions {
    int getValidNumber(int min, int max, const std::string& prompt) {
        int number;
        while (true) {
            std::cout << prompt;
            if (std::cin >> number) {
                if (number >= min && number <= max) {
                    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Очистка буфера
                    return number;
                } else {
                    std::cout << "Ошибка: введите число от " << min << " до " << max << "!" << std::endl;
                }
            } else {
                std::cout << "Ошибка: введите число!" << std::endl;
                std::cin.clear();
                std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            }
        }
    }
}#include "../h/import_export.h"
#include "../h/mmap_utils.h"
#include <json/json.h>
#include <stdexcept>

// Экспортирует пароли в JSON-файл через mmap
// TODO: Добавить шифрование JSON с использованием master_key
void ImportExport::exportPasswords(const std::string &buffer_file, const std::vector<PasswordEntry> &entries) {
    Json::Value root(Json::arrayValue);
    for (const auto& entry : entries) {
        Json::Value item;
        item["description"] = entry.description;
        item["login"] = entry.login;
        item["password"] = entry.password; // Пароль уже расшифрован
        root.append(item);
    }

    Json::StreamWriterBuilder builder;
    std::string json_data = Json::writeString(builder, root);
    MMAPUtils::writeImportExportBuffer(buffer_file, json_data);
}

// Импортирует пароли из JSON-файла через mmap
// TODO: Добавить расшифровку JSON с использованием master_key
std::vector<PasswordEntry> ImportExport::importPasswords(const std::string& buffer_file) {
    std::string json_data = MMAPUtils::readImportExportBuffer(buffer_file);
    Json::Value root;
    Json::CharReaderBuilder builder;
    std::unique_ptr<Json::CharReader> reader(builder.newCharReader());
    std::string errors;

    if (!reader->parse(json_data.c_str(), json_data.c_str() + json_data.size(), &root, &errors)) {
        throw std::runtime_error("Failed to parse JSON: " + errors);
    }

    std::vector<PasswordEntry> entries;
    for (const auto& item : root) {
        PasswordEntry entry;
        entry.description = item["description"].asString();
        entry.login = item["login"].asString();
        entry.password = item["password"].asString(); // Будет зашифрован при добавлении
        entries.push_back(entry);
    }

    return entries;
}
#include "../h/tui.h"
#include <stdexcept>
#include <iostream>
#include <ostream>

int main() {
    try {
        TUI tui("passwords.db", "master_key.bin", "totp_cache.bin");
        tui.run();
    } catch (const std::exception& e) {
        endwin();
        std::cerr << "Fatal error: " << e.what() << std::endl;
        return 1;
    }
    return 0;
}#include "../h/mmap_utils.h"
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdexcept>
#include <cstring>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <openssl/sha.h>
#include <iostream>

void MMAPUtils::initTOTPCache(const std::string& cache_file, size_t max_entries) {
    int fd = open(cache_file.c_str(), O_RDWR | O_CREAT, 0600);
    if (fd == -1) throw std::runtime_error("Failed to open TOTP cache file");

    size_t size = max_entries * sizeof(TOTPCacheEntry);
    if (ftruncate(fd, size) == -1) {
        close(fd);
        throw std::runtime_error("Failed to set TOTP cache file size");
    }

    void* addr = mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) {
        close(fd);
        throw std::runtime_error("Failed to mmap TOTP cache");
    }

    memset(addr, 0, size); // Очищаем кэш
    munmap(addr, size);
    close(fd);
}

bool MMAPUtils::addTOTPCacheEntry(const std::string& cache_file, int user_id, const std::string& code) {
    struct stat st;
    if (stat(cache_file.c_str(), &st) == -1) return false;

    int fd = open(cache_file.c_str(), O_RDWR);
    if (fd == -1) return false;

    size_t size = st.st_size;
    TOTPCacheEntry* entries = (TOTPCacheEntry*)mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (entries == MAP_FAILED) {
        close(fd);
        return false;
    }

    size_t max_entries = size / sizeof(TOTPCacheEntry);
    for (size_t i = 0; i < max_entries; ++i) {
        if (entries[i].user_id == 0) { // Пустая запись
            entries[i].user_id = user_id;
            strncpy(entries[i].code, code.c_str(), 7);
            entries[i].timestamp = time(nullptr);
            munmap(entries, size);
            close(fd);
            return true;
        }
    }

    munmap(entries, size);
    close(fd);
    return false;
}

bool MMAPUtils::isCodeInCache(const std::string& cache_file, int user_id, const std::string& code) {
    struct stat st;
    if (stat(cache_file.c_str(), &st) == -1) return false;

    int fd = open(cache_file.c_str(), O_RDONLY);
    if (fd == -1) return false;

    size_t size = st.st_size;
    TOTPCacheEntry* entries = (TOTPCacheEntry*)mmap(nullptr, size, PROT_READ, MAP_SHARED, fd, 0);
    if (entries == MAP_FAILED) {
        close(fd);
        return false;
    }

    size_t max_entries = size / sizeof(TOTPCacheEntry);
    time_t now = time(nullptr);
    bool found = false;
    for (size_t i = 0; i < max_entries; ++i) {
        if (entries[i].user_id == user_id && strcmp(entries[i].code, code.c_str()) == 0) {
            if (now - entries[i].timestamp < 30) {
                found = true;
            } else {
                entries[i].user_id = 0; // Очищаем устаревшую запись
            }
        }
    }

    munmap(entries, size);
    close(fd);
    return found;
}

void MMAPUtils::cleanupTOTPCache(const std::string& cache_file) {
    struct stat st;
    if (stat(cache_file.c_str(), &st) == -1) return;

    int fd = open(cache_file.c_str(), O_RDWR);
    if (fd == -1) return;

    size_t size = st.st_size;
    TOTPCacheEntry* entries = (TOTPCacheEntry*)mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (entries == MAP_FAILED) {
        close(fd);
        return;
    }

    size_t max_entries = size / sizeof(TOTPCacheEntry);
    time_t now = time(nullptr);
    for (size_t i = 0; i < max_entries; ++i) {
        if (entries[i].user_id != 0 && now - entries[i].timestamp >= 30) {
            entries[i].user_id = 0;
        }
    }

    munmap(entries, size);
    close(fd);
}

void MMAPUtils::writeImportExportBuffer(const std::string& buffer_file, const std::string& data) {
    int fd = open(buffer_file.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
    if (fd == -1) throw std::runtime_error("Failed to open import/export buffer file");

    size_t size = data.size();
    if (ftruncate(fd, size) == -1) {
        close(fd);
        throw std::runtime_error("Failed to set import/export buffer file size");
    }

    char* addr = (char*)mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) {
        close(fd);
        throw std::runtime_error("Failed to mmap import/export buffer");
    }

    memcpy(addr, data.data(), size);
    munmap(addr, size);
    close(fd);
}

std::string MMAPUtils::readImportExportBuffer(const std::string& buffer_file) {
    struct stat st;
    if (stat(buffer_file.c_str(), &st) == -1) {
        throw std::runtime_error("Import/export buffer file does not exist");
    }

    int fd = open(buffer_file.c_str(), O_RDONLY);
    if (fd == -1) throw std::runtime_error("Failed to open import/export buffer file");

    size_t size = st.st_size;
    char* addr = (char*)mmap(nullptr, size, PROT_READ, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) {
        close(fd);
        throw std::runtime_error("Failed to mmap import/export buffer");
    }

    std::string result(addr, size);
    munmap(addr, size);
    close(fd);
    return result;
}

void MMAPUtils::storeMasterKey(const std::string& key_file, const std::string& key, const std::string& encryption_key) {
    // Генерируем ключ шифрования для мастер-ключа
    unsigned char derived_key[32];
    if (!PKCS5_PBKDF2_HMAC(encryption_key.c_str(), encryption_key.length(), 
                           nullptr, 0, 10000, EVP_sha256(), 32, derived_key)) {
        throw std::runtime_error("Failed to derive encryption key for master key");
    }

    // Инициализация AES-256-GCM
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    if (!ctx) throw std::runtime_error("Failed to create cipher context");

    unsigned char iv[12];
    if (RAND_bytes(iv, 12) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to generate IV");
    }

    if (EVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), nullptr, nullptr, nullptr) != 1 ||
        EVP_EncryptInit_ex(ctx, nullptr, nullptr, derived_key, iv) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to initialize AES-256-GCM");
    }

    std::vector<unsigned char> ciphertext(key.size() + 16);
    int len, ciphertext_len;

    if (EVP_EncryptUpdate(ctx, ciphertext.data(), &len, (unsigned char*)key.c_str(), key.size()) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to encrypt master key");
    }
    ciphertext_len = len;

    if (EVP_EncryptFinal_ex(ctx, ciphertext.data() + len, &len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to finalize master key encryption");
    }
    ciphertext_len += len;

    unsigned char tag[16];
    if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_GET_TAG, 16, tag) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to get GCM tag");
    }

    EVP_CIPHER_CTX_free(ctx);

    // Сохраняем IV + шифрованный ключ + тег в файл через mmap
    size_t total_size = 12 + ciphertext_len + 16;
    int fd = open(key_file.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
    if (fd == -1) throw std::runtime_error("Failed to open master key file");

    if (ftruncate(fd, total_size) == -1) {
        close(fd);
        throw std::runtime_error("Failed to set master key file size");
    }

    unsigned char* addr = (unsigned char*)mmap(nullptr, total_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) {
        close(fd);
        throw std::runtime_error("Failed to mmap master key");
    }

    memcpy(addr, iv, 12);
    memcpy(addr + 12, ciphertext.data(), ciphertext_len);
    memcpy(addr + 12 + ciphertext_len, tag, 16);

    munmap(addr, total_size);
    close(fd);
}

std::string MMAPUtils::loadMasterKey(const std::string& key_file, const std::string& encryption_key) {
    struct stat st;
    if (stat(key_file.c_str(), &st) == -1) {
        throw std::runtime_error("Master key file does not exist");
    }

    if (st.st_size < 12 + 16) {
        throw std::runtime_error("Master key file is too small");
    }

    int fd = open(key_file.c_str(), O_RDONLY);
    if (fd == -1) throw std::runtime_error("Failed to open master key file");

    size_t size = st.st_size;
    unsigned char* addr = (unsigned char*)mmap(nullptr, size, PROT_READ, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) {
        close(fd);
        throw std::runtime_error("Failed to mmap master key");
    }

    unsigned char iv[12];
    memcpy(iv, addr, 12);
    size_t ciphertext_len = size - 12 - 16;
    std::vector<unsigned char> ciphertext(ciphertext_len);
    memcpy(ciphertext.data(), addr + 12, ciphertext_len);
    unsigned char tag[16];
    memcpy(tag, addr + 12 + ciphertext_len, 16);

    munmap(addr, size);
    close(fd);

    // Генерируем ключ расшифровки
    unsigned char derived_key[32];
    if (!PKCS5_PBKDF2_HMAC(encryption_key.c_str(), encryption_key.length(), 
                           nullptr, 0, 10000, EVP_sha256(), 32, derived_key)) {
        throw std::runtime_error("Failed to derive decryption key for master key");
    }

    // Инициализация AES-256-GCM
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    if (!ctx) throw std::runtime_error("Failed to create cipher context");

    if (EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), nullptr, nullptr, nullptr) != 1 ||
        EVP_DecryptInit_ex(ctx, nullptr, nullptr, derived_key, iv) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to initialize AES-256-GCM");
    }

    std::vector<unsigned char> plaintext(ciphertext_len);
    int len, plaintext_len;

    if (EVP_DecryptUpdate(ctx, plaintext.data(), &len, ciphertext.data(), ciphertext_len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to decrypt master key");
    }
    plaintext_len = len;

    if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, 16, tag) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to set GCM tag");
    }

    if (EVP_DecryptFinal_ex(ctx, plaintext.data() + len, &len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to finalize master key decryption");
    }
    plaintext_len += len;

    EVP_CIPHER_CTX_free(ctx);
    return std::string(plaintext.begin(), plaintext.begin() + plaintext_len);
}#include "../h/pass_gen.h"
#include <cstdlib>

std::string generatePassword(int length, bool useLower, bool useUpper, bool useDigits, bool useSymbols) {
    std::string chars;
    if (useLower) chars += "abcdefghijklmnopqrstuvwxyz";
    if (useUpper) chars += "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    if (useDigits) chars += "0123456789";
    if (useSymbols) chars += "!@#$%^&*()_+-=[]{}|;:,.<>?";

    if (chars.empty()) {
        return "";
    }

    std::string password;
    for (int i = 0; i < length; ++i) {
        password += chars[rand() % chars.length()];
    }
    return password;
}
#include "../h/totp.h"
#include <liboath/oath.h>
#include <stdexcept>
#include <random>
#include <ctime>
#include <iostream>

std::string TOTP::generateSecret() {
    const char* alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 31);

    char secret[17];
    for (int i = 0; i < 16; ++i) {
        secret[i] = alphabet[dis(gen)];
    }
    secret[16] = '\0';

    char* encoded = nullptr;
    size_t encoded_len = 0;
    if (oath_base32_encode(secret, 16, &encoded, &encoded_len) != OATH_OK) {
        if (encoded) free(encoded);
        throw std::runtime_error("Failed to encode TOTP secret");
    }

    std::string result(encoded, encoded_len);
    free(encoded);
    return result;
}

bool TOTP::verifyCode(const std::string& secret, const std::string& code) {
    if (secret.empty() || code.empty()) {
        std::cerr << "TOTP: Empty secret or code" << std::endl;
        return false;
    }

    if (code.length() != 6) {
        std::cerr << "TOTP: Invalid code length (must be 6 digits)" << std::endl;
        return false;
    }

    // Декодируем Base32 секрет
    char* decoded_secret = nullptr;
    size_t decoded_len = 0;
    int rc = oath_base32_decode(secret.c_str(), secret.length(), &decoded_secret, &decoded_len);
    if (rc != OATH_OK || decoded_secret == nullptr) {
        std::cerr << "TOTP: Secret decoding failed, rc=" << rc << std::endl;
        if (decoded_secret) free(decoded_secret);
        return false;
    }

    // Генерируем TOTP-код
    time_t now = time(nullptr);
    char totp_code[7];
    rc = oath_totp_generate(decoded_secret, decoded_len, now, 30, 0, 6, totp_code);
    free(decoded_secret);

    if (rc != OATH_OK) {
        std::cerr << "TOTP: Code generation failed, rc=" << rc << std::endl;
        return false;
    }

    // Сравниваем коды
    bool match = (code == totp_code);
    if (!match) {
        std::cerr << "TOTP: Code mismatch. Expected: " << totp_code << ", Got: " << code << std::endl;
    }

    return match;
}#include "../h/tui.h"
#include "../h/mmap_utils.h"
#include <ncursesw/cursesw.h>
#include <stdexcept>
#include <clocale>
#include <iostream>
#include <utility>


TUI::TUI(const std::string& db_path, std::string  key_file, const std::string& cache_file)
        : db(new Database(db_path)), key_file(std::move(key_file)), cache_file(cache_file),
          current_user_id(0), is_authenticated(false), main_win(nullptr), input_win(nullptr), status_win(nullptr) {
    setlocale(LC_ALL, "");
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0);
    initColors();
    int max_y, max_x;
    getmaxyx(stdscr, max_y, max_x);
    main_win = newwin(max_y - 5, max_x, 0, 0);
    input_win = newwin(3, max_x, max_y - 5, 0);
    status_win = newwin(2, max_x, max_y - 2, 0);
    keypad(main_win, TRUE);
    keypad(input_win, TRUE);
    keypad(status_win, TRUE);
    refreshWindows();
    if (!db->initialize()) {
        showError("Failed to initialize the database");
        throw std::runtime_error("Database initialization failed");
    }
    MMAPUtils::initTOTPCache(cache_file, 100);
}

TUI::~TUI() {
    delete db;
    delete crypto;
    delwin(main_win);
    delwin(input_win);
    delwin(status_win);
    endwin();
}

void TUI::initColors() {
    if (has_colors()) {
        start_color();
        init_pair(PAIR_DEFAULT, COLOR_WHITE, COLOR_BLACK);
        init_pair(PAIR_TITLE, COLOR_CYAN, COLOR_BLACK);
        init_pair(PAIR_MENU, COLOR_YELLOW, COLOR_BLACK);
        init_pair(PAIR_SUCCESS, COLOR_GREEN, COLOR_BLACK);
        init_pair(PAIR_ERROR, COLOR_RED, COLOR_BLACK);
        init_pair(PAIR_WARNING, COLOR_MAGENTA, COLOR_BLACK);
        init_pair(PAIR_HIGHLIGHT, COLOR_BLUE, COLOR_BLACK);
    }
}

void TUI::centerText(WINDOW* win, int y, const std::wstring& text, int pair) {
    int max_x = getmaxx(win);
    int x = (max_x - static_cast<int>(text.length())) / 2;
    if (x < 0) x = 0;
    wattron(win, COLOR_PAIR(pair));
    mvwaddnwstr(win, y, x, text.c_str(), text.length());
    wattroff(win, COLOR_PAIR(pair));
}

void TUI::showMainMenu() {
    wclear(main_win);
    box(main_win, 0, 0);
    centerText(main_win, 1, L"Password manager", PAIR_TITLE);
    centerText(main_win, 3, L"1. Registration", PAIR_MENU);
    centerText(main_win, 4, L"2. Log in", PAIR_MENU);
    centerText(main_win, 5, L"3. Log out", PAIR_MENU);
    wrefresh(main_win);
    int choice = getValidNumber(1, 3, "Choose option: ");
    switch (choice) {
        case 1: handleRegister(); break;
        case 2: handleLogin(); break;
        case 3: exit(0);
        default:
            std::cout << "Invalid choice" << std::endl;
            break;
    }
}

void TUI::showAuthenticatedMenu() {
    wclear(main_win);
    box(main_win, 0, 0);
    std::wstring welcome = L"Welcome, " + std::wstring(current_username.begin(), current_username.end());
    centerText(main_win, 1, welcome, PAIR_TITLE);
    centerText(main_win, 3, L"1. Add password", PAIR_MENU);
    centerText(main_win, 4, L"2. Delete password", PAIR_MENU);
    centerText(main_win, 5, L"3. View passwords", PAIR_MENU);
    centerText(main_win, 6, L"4. Generate the password", PAIR_MENU);
    centerText(main_win, 7, L"5. Import/export passwords", PAIR_MENU);
    centerText(main_win, 8, L"6. Exit", PAIR_MENU);
    wrefresh(main_win);
    int choice = getValidNumber(1, 6, "Choose option: ");
    switch (choice) {
        case 1: handleAddPassword(); break;
        case 2: handleRemovePassword(); break;
        case 3: handleViewPasswords(); break;
        case 4: handleGeneratePassword(); break;
        case 5: handleImportExport(); break;
        case 6: is_authenticated = false; current_user_id = 0; current_username.clear(); delete crypto; crypto = nullptr; break;
        default: std::cout << "Invalid choice" << std::endl;
            break;
    }
}

std::string TUI::getInput(const std::string& prompt, bool echo_input) {
    const int MAX_INPUT_ = 256;
    char input[MAX_INPUT_];
    wclear(input_win);
    box(input_win, 0, 0);
    mvwprintw(input_win, 1, 1, prompt.c_str());
    wrefresh(input_win);
    if (echo_input) {
        echo();
    } else {
        noecho();
    }
    wgetnstr(input_win, input, MAX_INPUT_ - 1);
    noecho();
    return std::string(input);
}

void TUI::handleLogin() {
    std::string username = getInput("Enter the user's name: ", true);
    std::string password = getInput("Enter the password: ", false);
    std::string password_hash = Crypto::hashPassword(password);
    std::string totp_secret;
    int user_id;


    if (db->authenticateUser(username, password_hash, user_id, totp_secret)) {
        if (totp_secret.empty()) {
            showError("An invalid TotP is a secret in the database. Please register again.");
            return;
        }
        std::string totp_code = getInput("Enter the TOTP code: ", true);
        if (MMAPUtils::isCodeInCache(cache_file, user_id, totp_code)) {
            showError("TOTP code has already been used.");
            return;
        }
        if (TOTP::verifyCode(totp_secret, totp_code)) {
            MMAPUtils::addTOTPCacheEntry(cache_file, user_id, totp_code);
            crypto = new Crypto(password, key_file);
            current_user_id = user_id;
            current_username = username;
            is_authenticated = true;
            showSuccess("The entrance is successful.");
        } else {
            showError("Inappropriate TOTP code.");
        }
    } else {
        showError("Invalid user name or password.");
    }
}

void TUI::handleRegister() {
    std::string username = getInput("Enter the user's name: ", true);
    std::string password = getInput("Enter the password: ", false);
    std::string password_hash = Crypto::hashPassword(password);
    std::string totp_secret = TOTP::generateSecret();
    showStatus("Your TOTP secret: " + totp_secret);
    std::string totp_code = getInput("Enter the current TOTP code: ", true);
    if (TOTP::verifyCode(totp_secret, totp_code)) {
        if (db->registerUser(username, password_hash, totp_secret)) {
            showSuccess("Registration is successful.");
        } else {
            showError("The user already exists or registration error.");
        }
    } else {
        showError("Inappropriate TOTP code.");
    }
}

void TUI::handleAddPassword() {
    if (!is_authenticated) {
        showError("First enter the system.");
        return;
    }
    std::string description = getInput("Enter the name of the service: ", true);
    std::string login = getInput("Enter the user's name: ", true);
    std::string password = getInput("Enter the password: ", false);
    std::string encrypted_password = crypto->encrypt(password);
    PasswordEntry entry = {description, login, encrypted_password};
    if (db->addPassword(current_user_id, entry)) {
        showSuccess("The password is added successfully.");
    } else {
        showError("Error when adding a password.");
    }
}

void TUI::handleRemovePassword() {
    if (!is_authenticated) {
        showError("First enter the system.");
        return;
    }
    std::string description = getInput("Enter the name of the service for deleting: ", true);
    if (db->removePassword(current_user_id, description)) {
        showSuccess("The password is removed successfully.");
    } else {
        showError("A password was not found or a removal error.");
    }
}

void TUI::handleViewPasswords() {
    if (!is_authenticated) {
        showError("First enter the system.");
        return;
    }
    std::vector<PasswordEntry> passwords;
    if (db->getPasswords(current_user_id, passwords)) {
        wclear(main_win);
        box(main_win, 0, 0);
        int y = 1;
        for (const auto& pass : passwords) {
            std::string decrypted_password = crypto->decrypt(pass.password);
            mvwprintw(main_win, y++, 1, "%s - %s: %s", pass.description.c_str(), pass.login.c_str(), decrypted_password.c_str());
        }
        wrefresh(main_win);
        wgetch(main_win);
    } else {
        showError("Error when receiving passwords.");
    }
}

void TUI::handleGeneratePassword() {
    std::string generated_password = generatePassword(16, true, true, true, true);
    showStatus("Generated password: " + generated_password);
    if (confirmAction("Want to add this password to the database?")) {
        std::string description = getInput("Enter the name of the service: ", true);
        std::string login = getInput("Enter the user's name: ", true);
        std::string encrypted_password = crypto->encrypt(generated_password);
        PasswordEntry entry = {description, login, encrypted_password};
        if (db->addPassword(current_user_id, entry)) {
            showSuccess("The password is added successfully.");
        } else {
            showError("Error when adding a password.");
        }
    }
}

void TUI::handleImportExport() {
    int choice = getValidNumber(1, 2, "1. Import\n2. Export\nChoose action: ");
    if (choice == 1) {
        std::string file_path = getInput("Enter the path to the import: ", true);
        std::vector<PasswordEntry> entries = ImportExport::importPasswords(file_path);
        for (const auto& entry : entries) {
            if (!db->addPassword(current_user_id, entry)) {
                showError("Error when importing password: " + entry.description);
            }
        }
        showSuccess("Import is successful.");
    } else if (choice == 2) {
        std::vector<PasswordEntry> passwords;
        if (db->getPasswords(current_user_id, passwords)) {
            std::string file_path = getInput("Enter the path to the export file: ", true);
            ImportExport::exportPasswords(file_path, passwords);
            showSuccess("Export is successful.");
        } else {
            showError("Error when receiving passwords for export.");
        }
    }
}

int TUI::getValidNumber(int min, int max, const std::string& prompt) {
    while (true) {
        std::string input = getInput(prompt, true);
        try {
            int number = std::stoi(input);
            if (number >= min && number <= max) {
                return number;
            } else {
                showError("The number outside the range. Please enter the number from " + std::to_string(min) + " to " + std::to_string(max) + ".");
            }
        } catch (const std::invalid_argument&) {
            showError("Inadmissible input. Please enter the number.");
        } catch (const std::out_of_range&) {
            showError("The number is too large. Please enter a smaller number.");
        }
    }
}

bool TUI::confirmAction(const std::string& prompt) const {
    wclear(input_win);
    box(input_win, 0, 0);
    mvwprintw(input_win, 1, 1, prompt.c_str());
    mvwprintw(input_win, 2, 1, " (y/n): ");
    wrefresh(input_win);
    int ch = wgetch(input_win);
    return ch == 'y' || ch == 'Y';
}

void TUI::showSuccess(const std::string& message) const {
    wclear(status_win);
    box(status_win, 0, 0);
    const std::wstring wmessage = L"✓ " + std::wstring(message.begin(), message.end());
    centerText(status_win, 1, wmessage, PAIR_SUCCESS);
    wrefresh(status_win);
    wgetch(status_win);
}

void TUI::showError(const std::string& message) const {
    wclear(status_win);
    box(status_win, 0, 0);
    const std::wstring wmessage = L"✗ " + std::wstring(message.begin(), message.end());
    centerText(status_win, 1, wmessage, PAIR_ERROR);
    wrefresh(status_win);
    wgetch(status_win);
}

void TUI::showStatus(const std::string& message) const {
    wclear(status_win);
    box(status_win, 0, 0);
    const auto wmessage = std::wstring(message.begin(), message.end());
    centerText(status_win, 1, wmessage, PAIR_DEFAULT);
    wrefresh(status_win);
    wgetch(status_win);
}

void TUI::refreshWindows() {
    wrefresh(main_win);
    wrefresh(input_win);
    wrefresh(status_win);
}

void TUI::run() {
    while (true) {
        if (!is_authenticated) {
            showMainMenu();
        } else {
            showAuthenticatedMenu();
        }
    }
}
=== crypto.cpp ===

#include "../h/crypto.h"
#include <fstream>
#include <stdexcept>
#include <openssl/sha.h>
#include <openssl/err.h>
#include "../h/mmap_utils.h"

// Constructor: initialize Crypto object with password and key file
Crypto::Crypto(const std::string& password, const std::string& key_file) : key_file(key_file), ctx(nullptr) {
    initializeContext();
    loadOrGenerateMasterKey(password);
}

// Destructor: clean up OpenSSL context
Crypto::~Crypto() {
    if (ctx) {
        EVP_CIPHER_CTX_free(ctx);
        ctx = nullptr;
    }
}

// Initialize OpenSSL cipher context
void Crypto::initializeContext() {
    ctx = EVP_CIPHER_CTX_new();
    if (!ctx) {
        throw std::runtime_error("Failed to create EVP context");
    }
}

// Load master key from file or generate a new one
void Crypto::loadOrGenerateMasterKey(const std::string& password) {
    // Check if key file exists
    if (std::ifstream(key_file)) {
        // Load and decrypt master key
        master_key = MMAPUtils::loadMasterKey(key_file, password);
    } else {
        // Generate new master key (32 bytes for AES-256)
        master_key.resize(32);
        if (RAND_bytes(reinterpret_cast<unsigned char*>(&master_key[0]), 32) != 1) {
            throw std::runtime_error("Failed to generate master key");
        }
        // Store master key in file
        MMAPUtils::storeMasterKey(key_file, master_key, password);
    }
}

// Static method to hash password using SHA-256
std::string Crypto::hashPassword(const std::string& password) {
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256_CTX sha256;
    SHA256_Init(&sha256);
    SHA256_Update(&sha256, password.c_str(), password.size());
    SHA256_Final(hash, &sha256);

    // Convert hash to hexadecimal string
    char hex[2 * SHA256_DIGEST_LENGTH + 1];
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        sprintf(hex + 2 * i, "%02x", hash[i]);
    }
    hex[2 * SHA256_DIGEST_LENGTH] = '\0';
    return std::string(hex);
}

// Encrypt plaintext using AES-256-GCM
std::string Crypto::encrypt(const std::string& plaintext) {
    if (plaintext.empty()) return "";

    unsigned char iv[12];
    if (RAND_bytes(iv, 12) != 1) {
        throw std::runtime_error("Failed to generate IV");
    }

    if (EVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, NULL) != 1 ||
        EVP_EncryptInit_ex(ctx, NULL, NULL, reinterpret_cast<const unsigned char*>(master_key.c_str()), iv) != 1) {
        throw std::runtime_error("Failed to initialize encryption");
    }

    std::string ciphertext;
    ciphertext.resize(plaintext.size() + EVP_MAX_BLOCK_LENGTH);
    int len, ciphertext_len = 0;

    if (EVP_EncryptUpdate(ctx, reinterpret_cast<unsigned char*>(&ciphertext[0]), &len,
                          reinterpret_cast<const unsigned char*>(plaintext.c_str()), plaintext.size()) != 1) {
        throw std::runtime_error("Failed to encrypt data");
    }
    ciphertext_len += len;

    if (EVP_EncryptFinal_ex(ctx, reinterpret_cast<unsigned char*>(&ciphertext[ciphertext_len]), &len) != 1) {
        throw std::runtime_error("Failed to finalize encryption");
    }
    ciphertext_len += len;

    unsigned char tag[16];
    if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_GET_TAG, 16, tag) != 1) {
        throw std::runtime_error("Failed to get GCM tag");
    }

    // Append IV and tag to ciphertext
    std::string result = std::string(reinterpret_cast<char*>(iv), 12) + ciphertext.substr(0, ciphertext_len) + std::string(reinterpret_cast<char*>(tag), 16);
    return result;
}

// Decrypt ciphertext using AES-256-GCM
std::string Crypto::decrypt(const std::string& ciphertext) {
    if (ciphertext.size() < 28) return ""; // Minimum size: 12 (IV) + 16 (tag)

    // Extract IV, ciphertext, and tag
    std::string iv = ciphertext.substr(0, 12);
    std::string tag = ciphertext.substr(ciphertext.size() - 16);
    std::string data = ciphertext.substr(12, ciphertext.size() - 28);

    if (EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL, NULL) != 1 ||
        EVP_DecryptInit_ex(ctx, NULL, NULL, reinterpret_cast<const unsigned char*>(master_key.c_str()),
                           reinterpret_cast<const unsigned char*>(iv.c_str())) != 1) {
        throw std::runtime_error("Failed to initialize decryption");
    }

    std::string plaintext;
    plaintext.resize(data.size() + EVP_MAX_BLOCK_LENGTH);
    int len, plaintext_len = 0;

    if (EVP_DecryptUpdate(ctx, reinterpret_cast<unsigned char*>(&plaintext[0]), &len,
                          reinterpret_cast<const unsigned char*>(data.c_str()), data.size()) != 1) {
        throw std::runtime_error("Failed to decrypt data");
    }
    plaintext_len += len;

    if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, 16, const_cast<char*>(tag.c_str())) != 1) {
        throw std::runtime_error("Failed to set GCM tag");
    }

    if (EVP_DecryptFinal_ex(ctx, reinterpret_cast<unsigned char*>(&plaintext[plaintext_len]), &len) != 1) {
        throw std::runtime_error("Failed to finalize decryption");
    }
    plaintext_len += len;

    return plaintext.substr(0, plaintext_len);
}
=== database.cpp ===

#include "../h/database.h"
#include <iostream>

Database::Database(const std::string& path) : db_path(path), db(nullptr) {
    int rc = sqlite3_open(db_path.c_str(), &db);
    if (rc != SQLITE_OK) {
        std::cerr << "Ошибка открытия базы данных: " << sqlite3_errmsg(db) << std::endl;
        sqlite3_close(db);
        db = nullptr;
    }
}

Database::~Database() {
    if (db) {
        sqlite3_close(db);
    }
}

bool Database::initialize() {
    if (!db) return false;

    const char* create_users_sql = 
        "CREATE TABLE IF NOT EXISTS users ("
        "id INTEGER PRIMARY KEY AUTOINCREMENT,"
        "username TEXT NOT NULL UNIQUE,"
        "password_hash TEXT NOT NULL,"
        "totp_secret TEXT NOT NULL);";

    const char* create_passwords_sql = 
        "CREATE TABLE IF NOT EXISTS passwords ("
        "id INTEGER PRIMARY KEY AUTOINCREMENT,"
        "user_id INTEGER NOT NULL,"
        "description TEXT NOT NULL,"
        "login TEXT NOT NULL,"
        "password BLOB NOT NULL,"
        "FOREIGN KEY (user_id) REFERENCES users (id));";

    char* err_msg = nullptr;
    int rc = sqlite3_exec(db, create_users_sql, nullptr, nullptr, &err_msg);
    if (rc != SQLITE_OK) {
        std::cerr << "Ошибка создания таблицы users: " << err_msg << std::endl;
        sqlite3_free(err_msg);
        return false;
    }

    rc = sqlite3_exec(db, create_passwords_sql, nullptr, nullptr, &err_msg);
    if (rc != SQLITE_OK) {
        std::cerr << "Ошибка создания таблицы passwords: " << err_msg << std::endl;
        sqlite3_free(err_msg);
        return false;
    }

    return true;
}

bool Database::registerUser(const std::string& username, const std::string& password_hash, const std::string& totp_secret) {
    if (!db) return false;

    const char* sql = "INSERT INTO users (username, password_hash, totp_secret) VALUES (?, ?, ?);";
    sqlite3_stmt* stmt;
    int rc = sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);
    if (rc != SQLITE_OK) {
        std::cerr << "Ошибка подготовки запроса: " << sqlite3_errmsg(db) << std::endl;
        return false;
    }

    sqlite3_bind_text(stmt, 1, username.c_str(), -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, password_hash.c_str(), -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, totp_secret.c_str(), -1, SQLITE_STATIC);

    rc = sqlite3_step(stmt);
    bool success = (rc == SQLITE_DONE);
    if (!success) {
        std::cerr << "Ошибка регистрации: " << sqlite3_errmsg(db) << std::endl;
    }

    sqlite3_finalize(stmt);
    return success;
}

bool Database::authenticateUser(const std::string& username, const std::string& password_hash, int& user_id, std::string& totp_secret) {
    if (!db) return false;

    const char* sql = "SELECT id, totp_secret FROM users WHERE username = ? AND password_hash = ?;";
    sqlite3_stmt* stmt;
    int rc = sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);
    if (rc != SQLITE_OK) {
        std::cerr << "Ошибка подготовки запроса: " << sqlite3_errmsg(db) << std::endl;
        return false;
    }

    sqlite3_bind_text(stmt, 1, username.c_str(), -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, password_hash.c_str(), -1, SQLITE_STATIC);

    rc = sqlite3_step(stmt);
    if (rc == SQLITE_ROW) {
        user_id = sqlite3_column_int(stmt, 0);
        totp_secret = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1));
        sqlite3_finalize(stmt);
        return true;
    }

    sqlite3_finalize(stmt);
    return false;
}

bool Database::addPassword(int user_id, const PasswordEntry& entry) {
    if (!db) return false;

    const char* sql = "INSERT INTO passwords (user_id, description, login, password) VALUES (?, ?, ?, ?);";
    sqlite3_stmt* stmt;
    int rc = sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);
    if (rc != SQLITE_OK) {
        std::cerr << "Ошибка подготовки запроса: " << sqlite3_errmsg(db) << std::endl;
        return false;
    }

    sqlite3_bind_int(stmt, 1, user_id);
    sqlite3_bind_text(stmt, 2, entry.description.c_str(), -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, entry.login.c_str(), -1, SQLITE_STATIC);
    sqlite3_bind_blob(stmt, 4, entry.password.data(), entry.password.size(), SQLITE_STATIC);

    rc = sqlite3_step(stmt);
    bool success = (rc == SQLITE_DONE);
    if (!success) {
        std::cerr << "Ошибка добавления записи: " << sqlite3_errmsg(db) << std::endl;
    }

    sqlite3_finalize(stmt);
    return success;
}

bool Database::removePassword(int user_id, const std::string& description) {
    if (!db) return false;

    const char* sql = "DELETE FROM passwords WHERE user_id = ? AND description = ?;";
    sqlite3_stmt* stmt;
    int rc = sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);
    if (rc != SQLITE_OK) {
        std::cerr << "Ошибка подготовки запроса: " << sqlite3_errmsg(db) << std::endl;
        return false;
    }

    sqlite3_bind_int(stmt, 1, user_id);
    sqlite3_bind_text(stmt, 2, description.c_str(), -1, SQLITE_STATIC);

    rc = sqlite3_step(stmt);
    bool success = (rc == SQLITE_DONE && sqlite3_changes(db) > 0);
    if (!success && sqlite3_changes(db) == 0) {
        std::cerr << "Запись не найдена!" << std::endl;
    }

    sqlite3_finalize(stmt);
    return success;
}

bool Database::getPasswords(int user_id, std::vector<PasswordEntry>& entries) {
    if (!db) return false;

    entries.clear();
    const char* sql = "SELECT description, login, password FROM passwords WHERE user_id = ?;";
    sqlite3_stmt* stmt;
    int rc = sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);
    if (rc != SQLITE_OK) {
        std::cerr << "Ошибка подготовки запроса: " << sqlite3_errmsg(db) << std::endl;
        return false;
    }

    sqlite3_bind_int(stmt, 1, user_id);

    while ((rc = sqlite3_step(stmt)) == SQLITE_ROW) {
        PasswordEntry entry;
        entry.description = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0));
        entry.login = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1));
        const void* blob = sqlite3_column_blob(stmt, 2);
        int blob_size = sqlite3_column_bytes(stmt, 2);
        entry.password = std::string(static_cast<const char*>(blob), blob_size);
        entries.push_back(entry);
    }

    sqlite3_finalize(stmt);
    return rc == SQLITE_DONE || !entries.empty();
}
=== exceptions.cpp ===

#include "../h/exceptions.h"
#include <iostream>
#include <limits>

namespace Exceptions {
    int getValidNumber(int min, int max, const std::string& prompt) {
        int number;
        while (true) {
            std::cout << prompt;
            if (std::cin >> number) {
                if (number >= min && number <= max) {
                    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Очистка буфера
                    return number;
                } else {
                    std::cout << "Ошибка: введите число от " << min << " до " << max << "!" << std::endl;
                }
            } else {
                std::cout << "Ошибка: введите число!" << std::endl;
                std::cin.clear();
                std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            }
        }
    }
}
=== import_export.cpp ===

#include "../h/import_export.h"
#include "../h/mmap_utils.h"
#include <json/json.h>
#include <stdexcept>

// Экспортирует пароли в JSON-файл через mmap
// TODO: Добавить шифрование JSON с использованием master_key
void ImportExport::exportPasswords(const std::string &buffer_file, const std::vector<PasswordEntry> &entries) {
    Json::Value root(Json::arrayValue);
    for (const auto& entry : entries) {
        Json::Value item;
        item["description"] = entry.description;
        item["login"] = entry.login;
        item["password"] = entry.password; // Пароль уже расшифрован
        root.append(item);
    }

    Json::StreamWriterBuilder builder;
    std::string json_data = Json::writeString(builder, root);
    MMAPUtils::writeImportExportBuffer(buffer_file, json_data);
}

// Импортирует пароли из JSON-файла через mmap
// TODO: Добавить расшифровку JSON с использованием master_key
std::vector<PasswordEntry> ImportExport::importPasswords(const std::string& buffer_file) {
    std::string json_data = MMAPUtils::readImportExportBuffer(buffer_file);
    Json::Value root;
    Json::CharReaderBuilder builder;
    std::unique_ptr<Json::CharReader> reader(builder.newCharReader());
    std::string errors;

    if (!reader->parse(json_data.c_str(), json_data.c_str() + json_data.size(), &root, &errors)) {
        throw std::runtime_error("Failed to parse JSON: " + errors);
    }

    std::vector<PasswordEntry> entries;
    for (const auto& item : root) {
        PasswordEntry entry;
        entry.description = item["description"].asString();
        entry.login = item["login"].asString();
        entry.password = item["password"].asString(); // Будет зашифрован при добавлении
        entries.push_back(entry);
    }

    return entries;
}

=== main.cpp ===

#include "../h/tui.h"
#include <stdexcept>
#include <iostream>
#include <ostream>

int main() {
    try {
        TUI tui("passwords.db", "master_key.bin", "totp_cache.bin");
        tui.run();
    } catch (const std::exception& e) {
        endwin();
        std::cerr << "Fatal error: " << e.what() << std::endl;
        return 1;
    }
    return 0;
}
=== mmap_utils.cpp ===

#include "../h/mmap_utils.h"
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdexcept>
#include <cstring>
#include <openssl/evp.h>
#include <openssl/rand.h>
#include <openssl/sha.h>
#include <iostream>

void MMAPUtils::initTOTPCache(const std::string& cache_file, size_t max_entries) {
    int fd = open(cache_file.c_str(), O_RDWR | O_CREAT, 0600);
    if (fd == -1) throw std::runtime_error("Failed to open TOTP cache file");

    size_t size = max_entries * sizeof(TOTPCacheEntry);
    if (ftruncate(fd, size) == -1) {
        close(fd);
        throw std::runtime_error("Failed to set TOTP cache file size");
    }

    void* addr = mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) {
        close(fd);
        throw std::runtime_error("Failed to mmap TOTP cache");
    }

    memset(addr, 0, size); // Очищаем кэш
    munmap(addr, size);
    close(fd);
}

bool MMAPUtils::addTOTPCacheEntry(const std::string& cache_file, int user_id, const std::string& code) {
    struct stat st;
    if (stat(cache_file.c_str(), &st) == -1) return false;

    int fd = open(cache_file.c_str(), O_RDWR);
    if (fd == -1) return false;

    size_t size = st.st_size;
    TOTPCacheEntry* entries = (TOTPCacheEntry*)mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (entries == MAP_FAILED) {
        close(fd);
        return false;
    }

    size_t max_entries = size / sizeof(TOTPCacheEntry);
    for (size_t i = 0; i < max_entries; ++i) {
        if (entries[i].user_id == 0) { // Пустая запись
            entries[i].user_id = user_id;
            strncpy(entries[i].code, code.c_str(), 7);
            entries[i].timestamp = time(nullptr);
            munmap(entries, size);
            close(fd);
            return true;
        }
    }

    munmap(entries, size);
    close(fd);
    return false;
}

bool MMAPUtils::isCodeInCache(const std::string& cache_file, int user_id, const std::string& code) {
    struct stat st;
    if (stat(cache_file.c_str(), &st) == -1) return false;

    int fd = open(cache_file.c_str(), O_RDONLY);
    if (fd == -1) return false;

    size_t size = st.st_size;
    TOTPCacheEntry* entries = (TOTPCacheEntry*)mmap(nullptr, size, PROT_READ, MAP_SHARED, fd, 0);
    if (entries == MAP_FAILED) {
        close(fd);
        return false;
    }

    size_t max_entries = size / sizeof(TOTPCacheEntry);
    time_t now = time(nullptr);
    bool found = false;
    for (size_t i = 0; i < max_entries; ++i) {
        if (entries[i].user_id == user_id && strcmp(entries[i].code, code.c_str()) == 0) {
            if (now - entries[i].timestamp < 30) {
                found = true;
            } else {
                entries[i].user_id = 0; // Очищаем устаревшую запись
            }
        }
    }

    munmap(entries, size);
    close(fd);
    return found;
}

void MMAPUtils::cleanupTOTPCache(const std::string& cache_file) {
    struct stat st;
    if (stat(cache_file.c_str(), &st) == -1) return;

    int fd = open(cache_file.c_str(), O_RDWR);
    if (fd == -1) return;

    size_t size = st.st_size;
    TOTPCacheEntry* entries = (TOTPCacheEntry*)mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (entries == MAP_FAILED) {
        close(fd);
        return;
    }

    size_t max_entries = size / sizeof(TOTPCacheEntry);
    time_t now = time(nullptr);
    for (size_t i = 0; i < max_entries; ++i) {
        if (entries[i].user_id != 0 && now - entries[i].timestamp >= 30) {
            entries[i].user_id = 0;
        }
    }

    munmap(entries, size);
    close(fd);
}

void MMAPUtils::writeImportExportBuffer(const std::string& buffer_file, const std::string& data) {
    int fd = open(buffer_file.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
    if (fd == -1) throw std::runtime_error("Failed to open import/export buffer file");

    size_t size = data.size();
    if (ftruncate(fd, size) == -1) {
        close(fd);
        throw std::runtime_error("Failed to set import/export buffer file size");
    }

    char* addr = (char*)mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) {
        close(fd);
        throw std::runtime_error("Failed to mmap import/export buffer");
    }

    memcpy(addr, data.data(), size);
    munmap(addr, size);
    close(fd);
}

std::string MMAPUtils::readImportExportBuffer(const std::string& buffer_file) {
    struct stat st;
    if (stat(buffer_file.c_str(), &st) == -1) {
        throw std::runtime_error("Import/export buffer file does not exist");
    }

    int fd = open(buffer_file.c_str(), O_RDONLY);
    if (fd == -1) throw std::runtime_error("Failed to open import/export buffer file");

    size_t size = st.st_size;
    char* addr = (char*)mmap(nullptr, size, PROT_READ, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) {
        close(fd);
        throw std::runtime_error("Failed to mmap import/export buffer");
    }

    std::string result(addr, size);
    munmap(addr, size);
    close(fd);
    return result;
}

void MMAPUtils::storeMasterKey(const std::string& key_file, const std::string& key, const std::string& encryption_key) {
    // Генерируем ключ шифрования для мастер-ключа
    unsigned char derived_key[32];
    if (!PKCS5_PBKDF2_HMAC(encryption_key.c_str(), encryption_key.length(), 
                           nullptr, 0, 10000, EVP_sha256(), 32, derived_key)) {
        throw std::runtime_error("Failed to derive encryption key for master key");
    }

    // Инициализация AES-256-GCM
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    if (!ctx) throw std::runtime_error("Failed to create cipher context");

    unsigned char iv[12];
    if (RAND_bytes(iv, 12) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to generate IV");
    }

    if (EVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), nullptr, nullptr, nullptr) != 1 ||
        EVP_EncryptInit_ex(ctx, nullptr, nullptr, derived_key, iv) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to initialize AES-256-GCM");
    }

    std::vector<unsigned char> ciphertext(key.size() + 16);
    int len, ciphertext_len;

    if (EVP_EncryptUpdate(ctx, ciphertext.data(), &len, (unsigned char*)key.c_str(), key.size()) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to encrypt master key");
    }
    ciphertext_len = len;

    if (EVP_EncryptFinal_ex(ctx, ciphertext.data() + len, &len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to finalize master key encryption");
    }
    ciphertext_len += len;

    unsigned char tag[16];
    if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_GET_TAG, 16, tag) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to get GCM tag");
    }

    EVP_CIPHER_CTX_free(ctx);

    // Сохраняем IV + шифрованный ключ + тег в файл через mmap
    size_t total_size = 12 + ciphertext_len + 16;
    int fd = open(key_file.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
    if (fd == -1) throw std::runtime_error("Failed to open master key file");

    if (ftruncate(fd, total_size) == -1) {
        close(fd);
        throw std::runtime_error("Failed to set master key file size");
    }

    unsigned char* addr = (unsigned char*)mmap(nullptr, total_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) {
        close(fd);
        throw std::runtime_error("Failed to mmap master key");
    }

    memcpy(addr, iv, 12);
    memcpy(addr + 12, ciphertext.data(), ciphertext_len);
    memcpy(addr + 12 + ciphertext_len, tag, 16);

    munmap(addr, total_size);
    close(fd);
}

std::string MMAPUtils::loadMasterKey(const std::string& key_file, const std::string& encryption_key) {
    struct stat st;
    if (stat(key_file.c_str(), &st) == -1) {
        throw std::runtime_error("Master key file does not exist");
    }

    if (st.st_size < 12 + 16) {
        throw std::runtime_error("Master key file is too small");
    }

    int fd = open(key_file.c_str(), O_RDONLY);
    if (fd == -1) throw std::runtime_error("Failed to open master key file");

    size_t size = st.st_size;
    unsigned char* addr = (unsigned char*)mmap(nullptr, size, PROT_READ, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) {
        close(fd);
        throw std::runtime_error("Failed to mmap master key");
    }

    unsigned char iv[12];
    memcpy(iv, addr, 12);
    size_t ciphertext_len = size - 12 - 16;
    std::vector<unsigned char> ciphertext(ciphertext_len);
    memcpy(ciphertext.data(), addr + 12, ciphertext_len);
    unsigned char tag[16];
    memcpy(tag, addr + 12 + ciphertext_len, 16);

    munmap(addr, size);
    close(fd);

    // Генерируем ключ расшифровки
    unsigned char derived_key[32];
    if (!PKCS5_PBKDF2_HMAC(encryption_key.c_str(), encryption_key.length(), 
                           nullptr, 0, 10000, EVP_sha256(), 32, derived_key)) {
        throw std::runtime_error("Failed to derive decryption key for master key");
    }

    // Инициализация AES-256-GCM
    EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
    if (!ctx) throw std::runtime_error("Failed to create cipher context");

    if (EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), nullptr, nullptr, nullptr) != 1 ||
        EVP_DecryptInit_ex(ctx, nullptr, nullptr, derived_key, iv) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to initialize AES-256-GCM");
    }

    std::vector<unsigned char> plaintext(ciphertext_len);
    int len, plaintext_len;

    if (EVP_DecryptUpdate(ctx, plaintext.data(), &len, ciphertext.data(), ciphertext_len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to decrypt master key");
    }
    plaintext_len = len;

    if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, 16, tag) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to set GCM tag");
    }

    if (EVP_DecryptFinal_ex(ctx, plaintext.data() + len, &len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        throw std::runtime_error("Failed to finalize master key decryption");
    }
    plaintext_len += len;

    EVP_CIPHER_CTX_free(ctx);
    return std::string(plaintext.begin(), plaintext.begin() + plaintext_len);
}
=== pass_gen.cpp ===

#include "../h/pass_gen.h"
#include <cstdlib>

std::string generatePassword(int length, bool useLower, bool useUpper, bool useDigits, bool useSymbols) {
    std::string chars;
    if (useLower) chars += "abcdefghijklmnopqrstuvwxyz";
    if (useUpper) chars += "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    if (useDigits) chars += "0123456789";
    if (useSymbols) chars += "!@#$%^&*()_+-=[]{}|;:,.<>?";

    if (chars.empty()) {
        return "";
    }

    std::string password;
    for (int i = 0; i < length; ++i) {
        password += chars[rand() % chars.length()];
    }
    return password;
}

=== totp.cpp ===

#include "../h/totp.h"
#include <liboath/oath.h>
#include <stdexcept>
#include <random>
#include <ctime>
#include <iostream>

std::string TOTP::generateSecret() {
    const char* alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 31);

    char secret[17];
    for (int i = 0; i < 16; ++i) {
        secret[i] = alphabet[dis(gen)];
    }
    secret[16] = '\0';

    char* encoded = nullptr;
    size_t encoded_len = 0;
    if (oath_base32_encode(secret, 16, &encoded, &encoded_len) != OATH_OK) {
        if (encoded) free(encoded);
        throw std::runtime_error("Failed to encode TOTP secret");
    }

    std::string result(encoded, encoded_len);
    free(encoded);
    return result;
}

bool TOTP::verifyCode(const std::string& secret, const std::string& code) {
    if (secret.empty() || code.empty()) {
        std::cerr << "TOTP: Empty secret or code" << std::endl;
        return false;
    }

    if (code.length() != 6) {
        std::cerr << "TOTP: Invalid code length (must be 6 digits)" << std::endl;
        return false;
    }

    // Декодируем Base32 секрет
    char* decoded_secret = nullptr;
    size_t decoded_len = 0;
    int rc = oath_base32_decode(secret.c_str(), secret.length(), &decoded_secret, &decoded_len);
    if (rc != OATH_OK || decoded_secret == nullptr) {
        std::cerr << "TOTP: Secret decoding failed, rc=" << rc << std::endl;
        if (decoded_secret) free(decoded_secret);
        return false;
    }

    // Генерируем TOTP-код
    time_t now = time(nullptr);
    char totp_code[7];
    rc = oath_totp_generate(decoded_secret, decoded_len, now, 30, 0, 6, totp_code);
    free(decoded_secret);

    if (rc != OATH_OK) {
        std::cerr << "TOTP: Code generation failed, rc=" << rc << std::endl;
        return false;
    }

    // Сравниваем коды
    bool match = (code == totp_code);
    if (!match) {
        std::cerr << "TOTP: Code mismatch. Expected: " << totp_code << ", Got: " << code << std::endl;
    }

    return match;
}
=== tui.cpp ===

#include "../h/tui.h"
#include "../h/mmap_utils.h"
#include <ncursesw/cursesw.h>
#include <stdexcept>
#include <clocale>
#include <iostream>
#include <utility>


TUI::TUI(const std::string& db_path, std::string  key_file, const std::string& cache_file)
        : db(new Database(db_path)), key_file(std::move(key_file)), cache_file(cache_file),
          current_user_id(0), is_authenticated(false), main_win(nullptr), input_win(nullptr), status_win(nullptr) {
    setlocale(LC_ALL, "");
    initscr();
    cbreak();
    noecho();
    keypad(stdscr, TRUE);
    curs_set(0);
    initColors();
    int max_y, max_x;
    getmaxyx(stdscr, max_y, max_x);
    main_win = newwin(max_y - 5, max_x, 0, 0);
    input_win = newwin(3, max_x, max_y - 5, 0);
    status_win = newwin(2, max_x, max_y - 2, 0);
    keypad(main_win, TRUE);
    keypad(input_win, TRUE);
    keypad(status_win, TRUE);
    refreshWindows();
    if (!db->initialize()) {
        showError("Failed to initialize the database");
        throw std::runtime_error("Database initialization failed");
    }
    MMAPUtils::initTOTPCache(cache_file, 100);
}

TUI::~TUI() {
    delete db;
    delete crypto;
    delwin(main_win);
    delwin(input_win);
    delwin(status_win);
    endwin();
}

void TUI::initColors() {
    if (has_colors()) {
        start_color();
        init_pair(PAIR_DEFAULT, COLOR_WHITE, COLOR_BLACK);
        init_pair(PAIR_TITLE, COLOR_CYAN, COLOR_BLACK);
        init_pair(PAIR_MENU, COLOR_YELLOW, COLOR_BLACK);
        init_pair(PAIR_SUCCESS, COLOR_GREEN, COLOR_BLACK);
        init_pair(PAIR_ERROR, COLOR_RED, COLOR_BLACK);
        init_pair(PAIR_WARNING, COLOR_MAGENTA, COLOR_BLACK);
        init_pair(PAIR_HIGHLIGHT, COLOR_BLUE, COLOR_BLACK);
    }
}

void TUI::centerText(WINDOW* win, int y, const std::wstring& text, int pair) {
    int max_x = getmaxx(win);
    int x = (max_x - static_cast<int>(text.length())) / 2;
    if (x < 0) x = 0;
    wattron(win, COLOR_PAIR(pair));
    mvwaddnwstr(win, y, x, text.c_str(), text.length());
    wattroff(win, COLOR_PAIR(pair));
}

void TUI::showMainMenu() {
    wclear(main_win);
    box(main_win, 0, 0);
    centerText(main_win, 1, L"Password manager", PAIR_TITLE);
    centerText(main_win, 3, L"1. Registration", PAIR_MENU);
    centerText(main_win, 4, L"2. Log in", PAIR_MENU);
    centerText(main_win, 5, L"3. Log out", PAIR_MENU);
    wrefresh(main_win);
    int choice = getValidNumber(1, 3, "Choose option: ");
    switch (choice) {
        case 1: handleRegister(); break;
        case 2: handleLogin(); break;
        case 3: exit(0);
        default:
            std::cout << "Invalid choice" << std::endl;
            break;
    }
}

void TUI::showAuthenticatedMenu() {
    wclear(main_win);
    box(main_win, 0, 0);
    std::wstring welcome = L"Welcome, " + std::wstring(current_username.begin(), current_username.end());
    centerText(main_win, 1, welcome, PAIR_TITLE);
    centerText(main_win, 3, L"1. Add password", PAIR_MENU);
    centerText(main_win, 4, L"2. Delete password", PAIR_MENU);
    centerText(main_win, 5, L"3. View passwords", PAIR_MENU);
    centerText(main_win, 6, L"4. Generate the password", PAIR_MENU);
    centerText(main_win, 7, L"5. Import/export passwords", PAIR_MENU);
    centerText(main_win, 8, L"6. Exit", PAIR_MENU);
    wrefresh(main_win);
    int choice = getValidNumber(1, 6, "Choose option: ");
    switch (choice) {
        case 1: handleAddPassword(); break;
        case 2: handleRemovePassword(); break;
        case 3: handleViewPasswords(); break;
        case 4: handleGeneratePassword(); break;
        case 5: handleImportExport(); break;
        case 6: is_authenticated = false; current_user_id = 0; current_username.clear(); delete crypto; crypto = nullptr; break;
        default: std::cout << "Invalid choice" << std::endl;
            break;
    }
}

std::string TUI::getInput(const std::string& prompt, bool echo_input) {
    const int MAX_INPUT_ = 256;
    char input[MAX_INPUT_];
    wclear(input_win);
    box(input_win, 0, 0);
    mvwprintw(input_win, 1, 1, prompt.c_str());
    wrefresh(input_win);
    if (echo_input) {
        echo();
    } else {
        noecho();
    }
    wgetnstr(input_win, input, MAX_INPUT_ - 1);
    noecho();
    return std::string(input);
}

void TUI::handleLogin() {
    std::string username = getInput("Enter the user's name: ", true);
    std::string password = getInput("Enter the password: ", false);
    std::string password_hash = Crypto::hashPassword(password);
    std::string totp_secret;
    int user_id;


    if (db->authenticateUser(username, password_hash, user_id, totp_secret)) {
        if (totp_secret.empty()) {
            showError("An invalid TotP is a secret in the database. Please register again.");
            return;
        }
        std::string totp_code = getInput("Enter the TOTP code: ", true);
        if (MMAPUtils::isCodeInCache(cache_file, user_id, totp_code)) {
            showError("TOTP code has already been used.");
            return;
        }
        if (TOTP::verifyCode(totp_secret, totp_code)) {
            MMAPUtils::addTOTPCacheEntry(cache_file, user_id, totp_code);
            crypto = new Crypto(password, key_file);
            current_user_id = user_id;
            current_username = username;
            is_authenticated = true;
            showSuccess("The entrance is successful.");
        } else {
            showError("Inappropriate TOTP code.");
        }
    } else {
        showError("Invalid user name or password.");
    }
}

void TUI::handleRegister() {
    std::string username = getInput("Enter the user's name: ", true);
    std::string password = getInput("Enter the password: ", false);
    std::string password_hash = Crypto::hashPassword(password);
    std::string totp_secret = TOTP::generateSecret();
    showStatus("Your TOTP secret: " + totp_secret);
    std::string totp_code = getInput("Enter the current TOTP code: ", true);
    if (TOTP::verifyCode(totp_secret, totp_code)) {
        if (db->registerUser(username, password_hash, totp_secret)) {
            showSuccess("Registration is successful.");
        } else {
            showError("The user already exists or registration error.");
        }
    } else {
        showError("Inappropriate TOTP code.");
    }
}

void TUI::handleAddPassword() {
    if (!is_authenticated) {
        showError("First enter the system.");
        return;
    }
    std::string description = getInput("Enter the name of the service: ", true);
    std::string login = getInput("Enter the user's name: ", true);
    std::string password = getInput("Enter the password: ", false);
    std::string encrypted_password = crypto->encrypt(password);
    PasswordEntry entry = {description, login, encrypted_password};
    if (db->addPassword(current_user_id, entry)) {
        showSuccess("The password is added successfully.");
    } else {
        showError("Error when adding a password.");
    }
}

void TUI::handleRemovePassword() {
    if (!is_authenticated) {
        showError("First enter the system.");
        return;
    }
    std::string description = getInput("Enter the name of the service for deleting: ", true);
    if (db->removePassword(current_user_id, description)) {
        showSuccess("The password is removed successfully.");
    } else {
        showError("A password was not found or a removal error.");
    }
}

void TUI::handleViewPasswords() {
    if (!is_authenticated) {
        showError("First enter the system.");
        return;
    }
    std::vector<PasswordEntry> passwords;
    if (db->getPasswords(current_user_id, passwords)) {
        wclear(main_win);
        box(main_win, 0, 0);
        int y = 1;
        for (const auto& pass : passwords) {
            std::string decrypted_password = crypto->decrypt(pass.password);
            mvwprintw(main_win, y++, 1, "%s - %s: %s", pass.description.c_str(), pass.login.c_str(), decrypted_password.c_str());
        }
        wrefresh(main_win);
        wgetch(main_win);
    } else {
        showError("Error when receiving passwords.");
    }
}

void TUI::handleGeneratePassword() {
    std::string generated_password = generatePassword(16, true, true, true, true);
    showStatus("Generated password: " + generated_password);
    if (confirmAction("Want to add this password to the database?")) {
        std::string description = getInput("Enter the name of the service: ", true);
        std::string login = getInput("Enter the user's name: ", true);
        std::string encrypted_password = crypto->encrypt(generated_password);
        PasswordEntry entry = {description, login, encrypted_password};
        if (db->addPassword(current_user_id, entry)) {
            showSuccess("The password is added successfully.");
        } else {
            showError("Error when adding a password.");
        }
    }
}

void TUI::handleImportExport() {
    int choice = getValidNumber(1, 2, "1. Import\n2. Export\nChoose action: ");
    if (choice == 1) {
        std::string file_path = getInput("Enter the path to the import: ", true);
        std::vector<PasswordEntry> entries = ImportExport::importPasswords(file_path);
        for (const auto& entry : entries) {
            if (!db->addPassword(current_user_id, entry)) {
                showError("Error when importing password: " + entry.description);
            }
        }
        showSuccess("Import is successful.");
    } else if (choice == 2) {
        std::vector<PasswordEntry> passwords;
        if (db->getPasswords(current_user_id, passwords)) {
            std::string file_path = getInput("Enter the path to the export file: ", true);
            ImportExport::exportPasswords(file_path, passwords);
            showSuccess("Export is successful.");
        } else {
            showError("Error when receiving passwords for export.");
        }
    }
}

int TUI::getValidNumber(int min, int max, const std::string& prompt) {
    while (true) {
        std::string input = getInput(prompt, true);
        try {
            int number = std::stoi(input);
            if (number >= min && number <= max) {
                return number;
            } else {
                showError("The number outside the range. Please enter the number from " + std::to_string(min) + " to " + std::to_string(max) + ".");
            }
        } catch (const std::invalid_argument&) {
            showError("Inadmissible input. Please enter the number.");
        } catch (const std::out_of_range&) {
            showError("The number is too large. Please enter a smaller number.");
        }
    }
}

bool TUI::confirmAction(const std::string& prompt) const {
    wclear(input_win);
    box(input_win, 0, 0);
    mvwprintw(input_win, 1, 1, prompt.c_str());
    mvwprintw(input_win, 2, 1, " (y/n): ");
    wrefresh(input_win);
    int ch = wgetch(input_win);
    return ch == 'y' || ch == 'Y';
}

void TUI::showSuccess(const std::string& message) const {
    wclear(status_win);
    box(status_win, 0, 0);
    const std::wstring wmessage = L"✓ " + std::wstring(message.begin(), message.end());
    centerText(status_win, 1, wmessage, PAIR_SUCCESS);
    wrefresh(status_win);
    wgetch(status_win);
}

void TUI::showError(const std::string& message) const {
    wclear(status_win);
    box(status_win, 0, 0);
    const std::wstring wmessage = L"✗ " + std::wstring(message.begin(), message.end());
    centerText(status_win, 1, wmessage, PAIR_ERROR);
    wrefresh(status_win);
    wgetch(status_win);
}

void TUI::showStatus(const std::string& message) const {
    wclear(status_win);
    box(status_win, 0, 0);
    const auto wmessage = std::wstring(message.begin(), message.end());
    centerText(status_win, 1, wmessage, PAIR_DEFAULT);
    wrefresh(status_win);
    wgetch(status_win);
}

void TUI::refreshWindows() {
    wrefresh(main_win);
    wrefresh(input_win);
    wrefresh(status_win);
}

void TUI::run() {
    while (true) {
        if (!is_authenticated) {
            showMainMenu();
        } else {
            showAuthenticatedMenu();
        }
    }
}